import React from 'react';

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = "/* chart */\n.styles_index__8Cayv {\n    color: #333333;\n    font-size: 14px;\n}\n\n.styles_fillCircle__2t9uJ {\n    fill: #ffb40a;\n    cursor: pointer;\n}\n.styles_fillCircle-completed__1o9S_{\n  fill: #64b927;\n  cursor: pointer;\n}\n\n.styles_shape__2Mf92 {\n    fill: #ffb40a;\n    opacity: .15;\n    border-radius: 0%;\n}\n\n.styles_shape__2Mf92:hover {\n    fill: #ffb40a;\n    opacity: .35;\n    z-index: 100;\n}\n\n.styles_scale__HH42x {\n    fill: #FAFAFA;\n    stroke: #999;\n    stroke-width: .15;\n}\n\n.styles_axis__3Eibh {\n    stroke: #555;\n    stroke-width: .15;\n}\n\n.styles_icon__s6Ddr {\n    background-color: #ffb40a;\n    border-radius: 50%;\n    cursor: pointer;\n}\n\n.styles_caption__2kquT {\n    fill: #ffb40a;\n    font-weight: 400;\n    font-size: 16px;\n}\n\n.styles_caption-completed__2AGjE {\n    fill: #64b927;\n    font-weight: 400;\n    font-size: 16px;\n}";
styleInject(css);

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

//
//let captionPoints = [];

// helper functions
var polarToX = function polarToX(angle, distance) {
    return Math.cos(angle - Math.PI / 2) * distance;
};

var polarToY = function polarToY(angle, distance) {
    return Math.sin(angle - Math.PI / 2) * distance;
};

var points = function points(_points) {
    return _points.map(function (point) {
        return point[0].toFixed(4) + ',' + point[1].toFixed(4);
    }).join(' ');
};

// const getPointsForCaption = (key, pointY) => {
//     let tempPoints = {};
//     if (captionPoints.length) {
//         captionPoints.forEach(element => {
//             if (element.key === key) {
//                 let val = (element.size * 2);
//                 val = (parseInt(val) + parseInt(element.pointY));
//                 if (val >= pointY) {
//                     tempPoints = {
//                         pointX: element.pointX,
//                         pointY: element.pointY - element.size * 1.5
//                     };
//                 }

//             }
//         });
//     }
//     return tempPoints;
// }

// const setPointsForCaptions = (key, pointX, pointY, size) => {
//     captionPoints.push({ key: key, pointX: pointX, pointY: pointY, size });
// }

// Click Handlers

var _onClick = function _onClick(options, col) {
    options.onClick(col);
};
var onShapeClick = function onShapeClick(options) {
    options.onShapeClick(options);
};

// drawing the cross lines over the circle
var axis = function axis(options) {
    return function (col, i) {
        return React.createElement('polyline', _extends({
            key: 'poly-axis-' + i,
            points: points([[0, 0], [polarToX(col.angle, options.size / options.drawSize), polarToY(col.angle, options.size / options.drawSize)]])
        }, options.axisProps(col)));
    };
};

// drawing the shapes inside the circles based on the data
var shape = function shape(columns, options) {
    return function (chartData, i) {
        return React.createElement('path', _extends({ key: 'shape-' + i,
            d: options.smoothing(columns.map(function (col) {
                var val = col.status;
                if (val > 1) {
                    val = val / 100;
                }
                if ('number' !== typeof val) {
                    throw new Error('Data set ' + i + ' is invalid.');
                }

                return [polarToX(col.angle, val * options.size / options.drawSize), polarToY(col.angle, val * options.size / options.drawSize)];
            })),
            onClick: function onClick() {
                return onShapeClick(options);
            }
        }, options.shapeProps()));
    };
};

// drawing the circles
var scale = function scale(options, value) {
    return React.createElement('circle', _extends({
        key: 'circle-' + value,
        cx: 0,
        cy: 0,
        r: value * options.size / options.drawSize
    }, options.scaleProps(value)));
};

// adding caption index
var index = 1;
var captionIndex = function captionIndex(options) {
    return function (col) {
        return React.createElement(
            'text',
            _extends({
                key: 'caption-of-' + col.key,
                x: polarToX(col.angle, options.size / 2 * 0.57).toFixed(4),
                y: polarToY(col.angle, options.size / 2 * 0.57).toFixed(4),
                dy: (options.indexProps().fontSize || 10) / 2
            }, options.indexProps()),
            index++
        );
    };
};

// adding the captions
var caption = function caption(options) {
    return function (col) {
        var style = col.status / 100 === 1 ? 'caption' : 'caption-completed';

        var distance = options.icons || options.circleFill ? 0.95 : 0.75;

        var pointX = polarToX(col.angle, options.size / 2 * distance).toFixed(4);
        var pointY = polarToY(col.angle, options.size / 2 * distance).toFixed(4);

        //let points = getPointsForCaption(col.key, pointY);

        return React.createElement(
            'text',
            _extends({
                key: 'caption-of-' + col.key,
                x: pointX,
                y: pointY,
                dy: (options.captionProps(col).fontSize || 10) / 2
            }, options.captionProps(style)),
            col.key
        );
    };
};

// drawing the circle and filling it will color based on the status
var circleFill = function circleFill(options) {
    return function (col) {
        var circleSize = options.size / 20;
        var imageSize = circleSize - 2;
        var style = col.status / 100 === 1 ? 'fillCircle' : 'fillCircle-completed';
        var pointX = polarToX(col.angle, options.size / 2 * 0.75).toFixed(4);
        var pointY = polarToY(col.angle, options.size / 2 * 0.75).toFixed(4);
        // setPointsForCaptions(col.key, pointX, pointY, circleSize);
        var imagePoints = { x: pointX - imageSize / 2, y: pointY - imageSize / 2 };
        return React.createElement(
            'g',
            null,
            React.createElement('circle', _extends({
                key: 'circle-of-' + col.key,
                r: circleSize,
                cx: pointX,
                cy: pointY,
                onClick: function onClick() {
                    return _onClick(options, col);
                }
            }, options.fillCircleProps(style))),
            React.createElement('image', _extends({ width: imageSize, height: imageSize, key: 'icon-of-' + col.key,
                x: imagePoints.x,
                y: imagePoints.y,
                xlinkHref: col.icon,
                onClick: function onClick() {
                    return _onClick(options, col);
                }
            }, options.iconProps(col)))
        );
    };
};

//adding the icons
var icon = function icon(options) {
    return function (col) {
        var pointX = polarToX(col.angle, options.size / 2 * 0.75).toFixed(4);
        var pointY = polarToY(col.angle, options.size / 2 * 0.75).toFixed(4);
        var imageSize = options.size / 10;
        var imagePoints = { x: pointX - imageSize / 2, y: pointY - imageSize / 2 };

        return React.createElement('image', _extends({ width: imageSize, height: imageSize, key: 'icon-of-' + col.key,
            x: imagePoints.x,
            y: imagePoints.y,
            xlinkHref: col.icon, onClick: function onClick() {
                return _onClick(options, col);
            }
        }, options.iconProps(col)));
    };
};

// rendering the Chart
var spider = function spider(data) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


    if (!Array.isArray(data)) {
        throw new Error('data must be an array');
    }
    props.size = props.size / props.zoomDistance;

    var columns = data.map(function (item, i, all) {
        return {
            key: item.caption,
            caption: caption[i],
            angle: Math.PI * 2 * i / all.length,
            icon: item.icon,
            status: item.status
        };
    });
    var groups = [React.createElement(
        'g',
        { key: 'g-groups' },
        columns.map(shape(columns, props))
    )];
    if (data) {
        if (props.icons) {
            groups.push(React.createElement(
                'g',
                { key: 'poly-icons' },
                columns.map(icon(props))
            ));
        } else if (props.circleFill) {
            groups.push(React.createElement(
                'g',
                { key: 'poly-circlefill' },
                columns.map(circleFill(props))
            ));
        }
        if (props.captionIndex) {
            index = 1;
            groups.push(React.createElement(
                'g',
                { key: 'poly-captionsindex' },
                columns.map(captionIndex(props))
            ));
        }
        if (props.captions) {
            groups.push(React.createElement(
                'g',
                { key: 'poly-captions' },
                columns.map(caption(props))
            ));
        }
    }
    if (props.axes) {
        groups.unshift(React.createElement(
            'g',
            { key: 'group-axes' },
            columns.map(axis(props))
        ));
    }

    if (props.scales > 0) {
        var scales = [];
        for (var i = props.scales; i > 0; i--) {
            scales.push(scale(props, i / props.scales));
        }
        groups.unshift(React.createElement(
            'g',
            { key: 'poly-scales' },
            scales
        ));
    }

    var delta = (props.size / 2).toFixed(4);
    return React.createElement(
        'g',
        { transform: 'translate(' + delta + ',' + delta + ')' },
        groups
    );
};

var noSmoothing = function noSmoothing(points) {
    var d = 'M' + points[0][0].toFixed(4) + ',' + points[0][1].toFixed(4);
    for (var i = 1; i < points.length; i++) {
        d += 'L' + points[i][0].toFixed(4) + ',' + points[i][1].toFixed(4);
    }
    return d + 'z';
};

var defaultProps = {
    size: 400,
    axes: true, // show axes?
    scales: 5, // show scale circles?
    captions: true, // show captions?
    captionIndex: true, // show caption indexes
    icons: true, // show icons
    circleFill: true,
    zoomDistance: 1, // where on the axes are the captions?
    drawSize: 4,
    smoothing: noSmoothing, // shape smoothing function
    captionMargin: 10,
    onClick: function iconOnClick(item) {
        //alert(item.key);
    },
    onShapeClick: function onShapeClick(item) {
        //alert(item.key);
    },
    axisProps: function axisProps() {
        return { className: 'axis' };
    },
    circleProps: function circleProps() {
        return { className: ' circle' };
    },
    indexProps: function indexProps() {
        return { className: 'index', fontSize: 14 };
    },
    scaleProps: function scaleProps() {
        return { className: 'scale', fill: 'none' };
    },
    shapeProps: function shapeProps() {
        return { className: 'shape' };
    },
    iconProps: function iconProps() {
        return { className: 'icon' };
    },
    fillCircleProps: function fillCircleProps() {
        return { className: "fillCircle" };
    },
    captionProps: function captionProps() {
        return {
            className: 'caption',
            textAnchor: 'middle',
            fontSize: 10,
            fontFamily: 'Source Sans Pro'
        };
    }
};

// Resizable Spider Chart Component
var SpiderChart = function SpiderChart(properties) {
    var data = properties.data,
        props = properties.props;
    var size = props.size;

    if (!size) {
        size = defaultProps.size;
    } else if (typeof size === "string") {
        size = parseInt(size);
    }
    var chartProps = _extends({}, defaultProps, props, { size: size });
    var chart = spider(data, chartProps);
    var captionMargin = chartProps.captionMargin;
    return React.createElement(
        'svg',
        {
            version: '1',
            xmlns: 'http://www.w3.org/2000/svg',
            width: size,
            height: size,
            viewBox: '-' + captionMargin + ' 0 ' + (size + captionMargin * 2) + ' ' + size,
            style: {
                padding: "20px", width: "100%", height: "100%"
            }
        },
        chart
    );
};

export default SpiderChart;
//# sourceMappingURL=index.es.js.map
